---
//@ts-nocheck

import Layout from '../layouts/Layout.astro';
import Tile from '../components/Tile.astro';
import Navbar from '../components/Navbar.astro';
import ProjectFrame from '../components/project/ProjectFrame.astro';
import Footer from '../components/Footer.astro';

import '../styles/animations.css';
import '../js/mobileHover.js';

import { contentfulClient } from '../lib/contentful';
import type { Project } from '../lib/contentful';

// Get URL parameters for pagination
const url = new URL(Astro.request.url);
const currentPage = parseInt(url.searchParams.get('page') || '1');
const TILES_PER_PAGE = 4; // Adjust this number as needed

const entries = await contentfulClient.getEntries<Project>({
  content_type: 'project',
  order: '-fields.date',
});

const allTiles = entries.items.map((item) => {
  const { title, subtitle, date, image, slug, columnNumber } = item.fields;
  return { title, subtitle, date, image, slug, columnNumber };
});

// Paginate the tiles
const totalTiles = allTiles.length;
const totalPages = Math.ceil(totalTiles / TILES_PER_PAGE);
const startIndex = (currentPage - 1) * TILES_PER_PAGE;
const endIndex = startIndex + TILES_PER_PAGE;

const paginatedTiles = allTiles.slice(startIndex, endIndex);
const hasNextPage = currentPage < totalPages;
---

<Layout>
  <div class="tiles-container">
    <!-- Map the paginated tiles -->
    {
      paginatedTiles.map((tile) => (
        <Tile
          title={tile.title}
          date={tile.date}
          image={`${tile.image.fields.file.url}`}
          slug={tile.slug}
          transition:name={`project-${tile.slug}`}
        />
      ))
    }
  </div>

  <!-- Hidden pagination link for infinite scroll -->
  {
    hasNextPage && (
      <a
        href={`?page=${currentPage + 1}`}
        class="pagination-next"
        style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;"
      >
        Next page
      </a>
    )
  }

  <!-- Loading and status indicators -->
  <div class="page-load-status">
    <div class="loader-ellips infinite-scroll-request">
      <span class="loader-ellips__dot"></span>
      <span class="loader-ellips__dot"></span>
      <span class="loader-ellips__dot"></span>
      <span class="loader-ellips__dot"></span>
    </div>
    <p class="infinite-scroll-error">Unable to load more projects</p>
  </div>

  {
    !hasNextPage && (
      <center>
        <p>More projects coming soon âœ¨</p>
      </center>
    )
  }

  <!-- Infinite Scroll, and Parallax initialization -->
  <script>
    // @ts-nocheck
    import InfiniteScroll from 'infinite-scroll';
    import ImagesLoaded from 'imagesloaded';

    document.addEventListener('astro:page-load', () => {
      const grid = document.querySelector('.tiles-container');

      // Make imagesLoaded available for InfiniteScroll
      InfiniteScroll.imagesLoaded = ImagesLoaded;

      // Initialize Infinite Scroll
      const infScroll = new InfiniteScroll(grid, {
        path: '.pagination-next',
        append: '.tile',
        status: '.page-load-status',
        scrollThreshold: 1200,
        // Use custom scroll container
        elementScroll: '.split-right',
        history: false,
      });

      const images = document.getElementsByClassName('tile-image');
      const scrollContainer = document.querySelector('.split-right');

      // When infinite scroll appends new items, reinitialize SimpleParallax
      infScroll.on('append', function () {
        setTimeout(initializeMouseEffects, 100);
      });

      setTimeout(initializeMouseEffects, 100);
    });

    // Image and shadow wiggle on mouseover
    function initializeMouseEffects() {
      const tiles = document.querySelectorAll('.tile');

      tiles.forEach((tile) => {
        const image = tile.querySelector('.tile-image');
        let isHovering = false;

        tile.addEventListener('mouseenter', () => {
          isHovering = true;
        });

        tile.addEventListener('mouseleave', () => {
          isHovering = false;
          // Reset shadow and image position
          tile.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
          if (image) {
            image.style.transform = 'translate(0, 0)';
          }
        });

        tile.addEventListener('mousemove', (e) => {
          if (!isHovering) return;

          const rect = tile.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          // Calculate mouse position relative to tile center
          const mouseX = e.clientX - centerX;
          const mouseY = e.clientY - centerY;

          // Shadow effect
          const shadowX = mouseX * 0.03;
          const shadowY = mouseY * 0.03;

          // Calculate distance for intensity
          const distance = Math.sqrt(mouseX * mouseX + mouseY * mouseY);
          const maxDistance =
            Math.sqrt(rect.width * rect.width + rect.height * rect.height) / 2;
          const intensity = Math.min(distance / maxDistance, 1);

          // Dynamic shadow
          const blur = 8 + intensity * 12;
          const opacity = 0.2 + intensity * 0.3;
          tile.style.boxShadow = `${shadowX}px ${shadowY}px ${blur}px 0px rgba(0, 0, 0, ${opacity})`;

          // Parallax effect on image
          if (image) {
            const parallaxX = mouseX * 0.01; // Subtle movement
            const parallaxY = mouseY * 0.01;
            image.style.transform = `translate(${parallaxX}px, ${parallaxY}px)`;
            image.style.transition = 'none'; // Remove transition for smooth movement
          }
        });
      });
    }
  </script>

  <style>
    .tiles-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      align-self: center;
      justify-content: center;
      gap: 20px;
      margin: 0 auto;
      width: 90%;
      margin-top: 20vh;
    }

    /* Loading status styles */
    .page-load-status {
      display: none;
    }
    .page-load-status.show {
      padding: 20px;
      text-align: center;
      color: var(--lightgrey);
    }

    .infinite-scroll-request {
      display: block;
    }

    .infinite-scroll-error {
      display: none;
    }

    .infinite-scroll-error.show {
      display: block;
    }

    .loader-ellips {
      font-size: 20px;
      position: relative;
      width: 4em;
      height: 1em;
      margin: 10px auto;
    }

    .loader-ellips__dot {
      display: block;
      width: 0.75em;
      height: 0.75em;
      border-radius: 0.5em;
      background: var(--darkgrey);
      position: absolute;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .loader-ellips__dot:nth-child(1) {
      left: 0;
      animation-delay: 0s;
    }
    .loader-ellips__dot:nth-child(2) {
      left: 1.5em;
      animation-delay: 0.3s;
    }
    .loader-ellips__dot:nth-child(3) {
      left: 3em;
      animation-delay: 0.6s;
    }
    .loader-ellips__dot:nth-child(4) {
      left: 4.5em;
      animation-delay: 0.9s;
    }

    @keyframes pulse {
      0%,
      80%,
      100% {
        transform: scale(0.8);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    center {
      margin: 20px 0;
      color: #999;
    }
  </style>
</Layout>
